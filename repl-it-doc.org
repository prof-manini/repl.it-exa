* headers                                                          :noexport:

#+INCLUDE: ~/standard-org-latex-export-headers.org
#+TITLE: Appunti sul "servizio" repl.it
#+AUTHOR: Luca Manini\footnote{\textcopyright\ 2020 Luca Manini}
#+DATE: Ottobre 2020
#+OPTIONS: toc:nil        no default TOC at all

* setup                                                            :noexport:

#+BEGIN_SRC elisp :results output
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)
(setq org-babel-load-languages
        '((emacs-lisp . t)
          (python . t)
          (sh . t)
          (sqlite . t)))
(setq python-shell-interpreter "python3")
#+END_SRC

#+RESULTS:

* Introduzione

  Alcuni appunti su "servizio" =repl.it= che utilizzeremo per fare
  esercizio di programmazione, sia in Python che in SQL (database).

* repl.it

  [[https://repl.it/][repl.it]] è uno strumento on-line via browser (Firefox e parenti) che
  permette di fare delle sessioni di programmazione in tantissimi
  linguaggi diversi, tra cui Python.

** Una nota sul nome del servizio.

   *repl* è un acronimo molto usato in informatica e sta per *read eval
   print loop*. Come spesso capita con gli acronimi in Inglese, anche
   questo si legge da destra a sinistra quindi si tratta di un
   programma che lavora in un *ciclo* (/loop/) in cui *stampa* (/ptiny/) ciò
   che ottiene *valutando* (/evaluate/) l'espressione che ha *letto* (/read/).

   Un repl è quindi, in generale, un'interfaccia utente (/user
   interface/) *testuale*, spesso chiamata anche *a linea di comando*
   (/command line/) verso un programma.  In questo caso il programma è
   un *interprete Python*, ossia un programma che è in grado di leggere,
   comprendere ed eseguire codice Python.

** Partenza

   Io non ho mai usato questo strumento prima d'ora e quindi:

   1. siamo tutti sulla stessa barca e sarà importante aiutarci a
      vicenda,
   2. secondo in questi appunti non do niente per scontato, anche se
      forse voi avete già fatto pratica e forse ne sapete più di me!

   Le prime funzionalità che mi pare utilizzeremo sono:

   1. la possibilità di creare e salvare più file sorgente (ossia file
      che contengono codice Python) che compariranno poi sulla colonna
      di sinistra,

   2. la possibilità di eseguire il codice presente in questi file,
      utilizzando il mega pulsante verde con la scritta RUN.
      *Attenzione*: repl esegue sempre e solo (direi) il file =main.py=,
      quindi almeno all'inizio useremo solo quello!

   3. la possibilità utilizzare Python in modalità "interattiva"
      scrivendo direttamente il codice nella finestra di destra (la
      stessa dove viene scritto ciò che stampa (/print/) il codice
      eseguito da file,

   4. la possibilità di usare, in futuro dopo che vi avrò spiegato
      cos'è a cosa serve e come si usa, un sistema di controllo di
      revisione,

** Iscrizione (account)

   Fortunatamente (ormai è purtroppo abbastanza raro), repl.it si può
   usare direttamente senza bisogno di registrarsi (/to sign up/) ma
   la registrazione è necessaria sia per poter "salvare" i sorgenti
   sia per poter utilizzare il sistema di controllo di revisione (vedi
   oltre).

* Python
** L'interprete interattivo

   Python è un linguaggio *interpretato*, il che vuol dire che il codice
   sorgente viene eseguito "così com'è" direttamente da un programma
   chiamato *interprete* invece di essere tradotto, da un programma
   chiamato di solito *compilatore* in un altro linguaggio comprensibile
   (ed eseguibile) da "un altro esecutore" (ad esempio "la CPU").

   Python, come succede spesso ma non sempre con i linguaggi
   interpretati, è anche un linguaggio *interattivo,* il che significa
   che è possibile "direttamente" scrivendo singole linee di codice
   che vengono eseguite "subito" e il cui risultato (se c'è) viene
   anche visualizzato (stampato) subito, *senza bisogno di usare la
   funzione print*!

   Questa modalità non è comoda per scrivere programmi di una certa
   lunghezza, ma è comodissima, tra le altre cose, per fare un po' di
   pratica con i concetti, i tipi di dato e le funzionalità di base
   del linguaggio.

*** Pratica

    Vediamo quindi di fare un po' di pratica.

**** Espressioni semplici

     1. se scrivo 123 (e poi invio) l'interprete stampa 123, la
        ragione è che 123 è una *espressione* (anche se banale visto che
        è un literal), l'interprete la *valuta*, ottiene un *valore* a cui
        probabilmente siamo interessati e quindi lo stampa (senza
        dover usare print).

     2. se scrivo =a = 123=, l'interprete non stampa nulla, perché in
        Python le assegnazioni non sono espressioni, non hanno un
        valore e quini c'è poco da stampare!

     3. se però adesso scrivo =a=, l'interprete stampa 123, perché =a=
        (così da solo) è una espressione (un po' meno banale di un
        /literal/), quindi viene valutata, si ottiene un valore che
        viene stampato.

**** Tipi di dato

     Abbiamo già parlato di tipi di dato (/data types/) in generale e
     del fatto che anche in Python un dato è sempre di un certo tipo,
     che posso ottenere con la "funzione" =type=. Vediamo cosa ottengo
     se uso =type= passando un /literal/, un nome o una espressione.
 #+BEGIN_SRC python :eval never
>>> type(123)
<class 'int'>
>>> a = 123
>>> type(a)
<class 'int'>
>>> type(100 + 23)
<class 'int'>
 #+END_SRC

    Ottengo sempre lo stesso risultato, che indica che il tipo è =int=.
    Fate però attenzione: ciò non significa che il nome =a= è di tipo
    =int= o che l'espressione =123 + 543= è di tipo =int=; in tutti e tre i
    casi, come sempre, il *parametro attuale* che io passo ad una
    funzione viene prima di tutto valutato e poi *passato* alla
    funzione.  Ciò implica che in tutti e tre i casi, alla funzione
    =type= attiva un =123=, che è di tipo =int=!

    *Esercizio*: provate ad usare =type= con altri tipi di dato che
    conoscete.

**** Help

     Un'altra funzionalità da sfruttare nella modalità interattiva è
     la funzione =help=, che dà accesso alla documentazione
     /on-line/. Notare: l'informazione fornita da =help= è "interna" agli
     oggetti di cui chiedete la documentazione stessa ed è quindi
     sempre disponibile (non viene cercata su un qualche file esterno
     o in rete!).

     Vediamo un esempio con =help(print)=:
 #+BEGIN_SRC python :eval never
>>> help(print)
Help on built-in function print in module builtins:

print(...)
    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file:  a file-like object (stream); defaults to the current sys.stdout.
    sep:   string inserted between values, default a space.
    end:   string appended after the last value, default a newline.
    flush: whether to forcibly flush the stream.
 #+END_SRC

     Breve spiegazione:

     1. la prima riga ci dice che =print= è una funzione (/function/), in
        particolare è una funzione /built-in/ (ossia "già presente"
        nell'interprete) e che è definita nel modulo =builtins= (vedremo
        poi cosa sono i moduli).

     2. la riga successiva mostra la /signature/ della funzione, in
        pratica (potete pensare che sia) ciò che c'è scritto dopo =def=
        nella definizione di una funzione qualsiasi.

     3. =value= indica è il dato che vogliamo stampare,

     4. i tre puntini indicano che è possibile passare altri argomenti
        oltre al primo,

     5. =sep=, =end=, =file= e =flush= rappresentano degli argomenti opzionali
        (che vedremo nelle prossime lezioni...), e il valore dopo il
        segno di uguale indica il valore per difetto (/default value/)
        ossia il valore usato se non ne forniamo uno esplicitamente,

     6. le righe successive danno informazioni di dettaglio sui vari
        argomenti.

     *Nota importante*: quando definiamo delle funzioni, possiamo
     fornire la documentazione in una /docstring/, ossia in una stringa
     posta subito dopo la riga =def=.  Un esempio vale mille parole:

 #+BEGIN_SRC python :eval never
>>> def hello(who):
...     "Say hello to WHO"
...     print("Hello " + who)
...
>>> hello("World")
Hello World
>>> help(hello)
Help on function hello in module __main__:

hello(who)
    Say hello to WHO
 #+END_SRC

**** Completion (completamento?)

     Un'altra funzionalità molto utile è il completamento automatico.
     Molti "strumenti di sviluppo" forniscono un qualche meccanismo che
     "scrive per voi" o che almeno suggerisce cosa potreste scrivere.
     Uno molto utile è il completamento, in particolare il
     completamento delle "proprietà" (attributi, metodi etc.).

     Per esempio: se io ho una stringa e non sono bene "cosa posso
     farci", posso cercare tra i *metodi* (parenti delle funzioni)
     disponibili e per fare ciò mi basta scrivere un nome (purtroppo
     non funziona con i /literal/) e usare il tasto =TAB=.

     Esempio (in cui ho tolto alcune righe... e in cui nella seconda
     riga, dopo =name.= ho premuto il tasto =TAB=).
 #+BEGIN_SRC python :eval never
>>> name = "Luca"
>>> name.
name.capitalize(    name.isalpha(       name.ljust(         name.split(
name.casefold(      name.isascii(       name.lower(         name.splitlines(
name.center(        name.isdecimal(     name.lstrip(        name.startswith(
............................................................................
name.index(         name.isupper(       name.rsplit(
name.isalnum(       name.join(          name.rstrip(
>>> help(name.lower)
Help on built-in function lower:

lower() method of builtins.str instance
    Return a copy of the string converted to lowercase.

>>> name.lower()
'luca'
 #+END_SRC

** Qualche "trucco" comodo

   Adesso abbiamo fatto una prova per vedere se la funzione =sum_pos=
   funziona correttamente; ma ovviamente una singola prova è un po'
   poco e soprattutto il "controllo" dobbiamo farlo noi, controllando
   ciò che stampa il codice di esempio.

   Per rendere il tutto un po' più comodo possiamo usare qualche
   trucco (in realtà non ci sono trucchi, ci sono solo modi
   intelligenti di usare le funzionalità del linguaggio!).

*** Esecuzione di più esempi

    Prima di tutto vediamo come eseguire la funzione =sum_pos= più
    volte con dati diversi.  La funzione richiede come argomento una
    lista (o simile) di interi, e quindi per fare più "giri" ci serve
    una lista di liste.
#+NAME: sum-pos-multi-test-0
#+BEGIN_SRC python :session py :results output :exports both
data = (
    (1,2,3),
    (0, -5, 7),
    (3 -4, 0, 2),
    )
for ii in data:
    t = sum_pos(ii)
    print(ii, "->", t)
#+END_SRC

#+RESULTS: sum-pos-multi-test-0
: (1, 2, 3) -> 6
: (0, -5, 7) -> 7
: (-1, 0, 2) -> 2

** Codice "da file"

   Vediamo adesso anche un esempio in cui scriviamo del codice in un
   file e poi lo eseguiamo.

   1. usiamo il file =main.py= già creato da =repl=,

   2. inseriamo una funzione =sum_pos= che dato un "insieme di numeri"
      *calcola e restituisce* la somma dei soli positivi.
 #+BEGIN_SRC python :session py :results silent
def sum_pos(ints):
    "The sum of the elements in INTS"
    t = 0              # creo un "accumulatore" nullo
    for i in ints:     # ciclo su tutti gli elementi di INTS
        if i > 0:      # e solamente se quello corrente è positivo
            t += i     # lo sommo all'accumulatore
    return t           # restituisco il risultato
 #+END_SRC

   3. per fare un primo controllo proviamo ad usare la funzione in un
      paio di esempi,

 #+NAME: sum-pos-test-0
 #+BEGIN_SRC python :session py :results output :exports both
ii = (2,3,4,0-12)
t = sum_pos(ii)
print(ii, "->", t)
 #+END_SRC

 #+RESULTS: sum-pos-test-0
 : (2, 3, 4, -12) -> 9

* SQL

  Oltre che per la programmazione in un linguaggio "generico" (/general
  purpose/) come Python, useremo repl.it anche per imparare e fare
  pratica con SQL, un linguaggio orientato ai database.

  Il linguaggio SQL nasce negli anni settanta, ed è quindi uno dei
  linguaggio più vecchi tra quelli ancora in uso.  In tutti questi
  anni è ovviamente cambiato moltissimo, ne sono nate molte versioni
  (dialetti) e nonostante gli sforzi di standardizzazione ancora
  adesso è meglio essere pronti a trovare differenze anche
  significative tra le varie implementazioni.

  Anche l'SQL, come Python, si può considerare, almeno per l'uso che
  ne faremo noi, un linguaggio "interpretato e interattivo"; ciò fa sì
  che si presti ad essere utilizzato in un ambiente come quello
  fornito da repl.it.

** SQLite

   Come sapete, i [[https://en.wikipedia.org/wiki/Database][database]] sono dei "contenitori di dati strutturati",
   che servono da "base" per multiple applicazioni, e che sono
   generalmente "gestiti" da software molto complessi chiamati DBMS
   ([[https://en.wikipedia.org/wiki/Database#Database_management_system][database management systems]]) che funzionano tipicamente in
   modalità /client server/ (con il DBMS che gira su un computer e le
   "applicazioni" che girano su altre macchine).  Esempi di database
   di questo tipo sono [[https://en.wikipedia.org/wiki/PostgreSQL][Postgres]] o [[https://en.wikipedia.org/wiki/Oracle_Database][Oracle]].

   Noi però useremo [[https://en.wikipedia.org/wiki/SQLite][SQLite]], un sistema molto più semplice e "leggero"
   che ha vari vantaggi:

   1. accettare un SQL relativamente completo e "standard",
   2. viene usato spesso /embedded/ in altre applicazioni (ad esempio
      per l'agenda dei telefoni Android o per le "preference" di vari
      browser),
   3. è molto comodo da usare anche da Python.

   XXX vi consiglio di scaricarvi in locale la [[https://sqlite.org/2020/sqlite-doc-3330000.zip][documentazione di
   riferimento]].

** Esempio

   In questo semplice esempio vedremo come usare le funzionalità di
   base dell'SQL per creare una tabella ed inserire ed "estrarre"
   alcuni dati.  Questa è la sequenza tipica di qualsiasi "esempio",
   grande o piccolo che sia. Vedremo poi alcuni "comandi" di SQLite
   che non fanno parte del linguaggio SQL ma che sono molto utili
   nell'interazione con l'interprete.

*** Creazione del database

    Nella maggioranza dei DBMS, la prima operazione da fare è creare
    un database, nel senso di creare il file (o più spesso l'insieme
    di file) su cui vengono "salvati" (in termine tecnico "resi
    persistenti") i dati.

    Siccome SQLite è pensato per operare fondamentalmente in memoria
    questa operazione non è in linea di principio necessaria; esiste
    comunque un comando (non SQL) per salvare i dati in un file (con
    "db" come estensione di /default/) e un altro comando per
    "ricaricarlo".

    In pratica SQLite crea automaticamente un database in memoria di
    nome =main:= ed è per questo che anche usando =repl.it= non avremo
    bisogno di preoccuparci di questo aspetto.

*** Creazione tabella

    La prima cosa che viene in mente di fare è giustamente creare una
    tabella, ma quando si stanno facendo degli esempi è normale
    "rieseguire" ogni volta tutto il codice, ma cercare di creare una
    tabella se questa esiste già è un errore.  La soluzione che si usa
    normalmente è cancellare la tabella (con l'istruzione SQL =drop
    table=) per poi ricrearla.  Peccato che anche cancellare una
    tabella che non esiste è un errore!  Fortunatamente, in molti SQL
    si può usare il seguente codice, che credo non richieda
    spiegazioni.

    *Nota*: le istruzioni SQL *devono* essere terminate con un punto e
    virgola (/semicolon/)!

#+header: :dir ./
#+header: :db exa.db
#+begin_src sqlite :results silent
drop table if exists Person;
#+end_src

    Per creare la tabella si usa l'istruzione =create table=, che come
    si può immaginare richiede di specificare il nome della tabella e
    la lista delle colonne.

    *Nota:* come già detto l'SQL è un linguaggio molto "variabile",
    quindi quasi tutte le affermazioni sulla sua sintassi vanno prese
    un po' con le pinze.  In ogni caso, l'SQL è *fondamentalmente non*
    /case sentitive/, quindi *in genere* "non distingue maiuscole e
    minuscole".  È però assolutamente vitale essere coerenti e non
    sfruttare questo fatto.  Se decidete, come faccio io, di scrivere
    quasi tutto minuscolo, fatelo sempre!

    Qui creo una tabella =Person= con tre colonne =id=, =name= e
    =code=. La colonna =id= serve da chiave primaria.

    Per una lista dei tipi di dato gestiti da SQLite basta consultare
    la documentazione [[https://www.sqlite.org/datatype3.html][on-line]].

    *Nota:* nella sua semplicità, SQLite ha in realtà pochi tipi di dato
    "nativi" (TEXT, NUMERIC, INTEGER, REAL, BLOB) che vengono poi
    utilizzati "al posto" di quelli più normali per l'SQL (come =CHAR= o
    =VARCHAR=).

    *Nota:* la chiave primaria è spesso un intero senza particolare
    "significato" (per dire, non è come il "codice fiscale" o la
    coppia "nome/cognome") e l'unica caratteristica importante è che
    deve essere *sempre presente* (vincolo =not null= in SQL) e *deve
    avere un valore* in ogni riga ( vincolo =unique= in SQL).  Quando si
    inseriscono delle righe è quindi obbligatorio specificare un
    valore, e con il vincolo di unicità la cosa diventa una
    scocciatura!  Tutti (?) i database forniscono dei meccanismi per
    generare questi valori in modo automatico, spesso semplicemente
    specificando un attributo =autoincrement=.  SQLite ha un meccanismo
    diverso; *in pratica*, se si dichiara una colonna =integer primary
    key=, il suo valore, se non specificato nelle =insert= viene gestito
    automaticamente dal sistema (il come non ci interessa).

#+header: :dir ./
#+header: :db exa.db
#+begin_src sqlite :results silent
-- Esempio di creazione di una tabella (questo è un commento!)
create table Person (              -- nomi delle tabelle "capitalized"
    id integer primary key,        -- vincolo di PK
    name varchar[25] not null,     -- vincolo di unicità (sulla singola colonna)
    code char[5] not null unique,
    age integer not null           -- ultima riga SENZA virgola!
);
#+end_src

*** Giusto per farsi un'idea

    Una piccola parentesi (che potete saltare) giusto per mostrare
    quanto sia "strano" l'SQL in quanto alla questione /case/.

#+header: :dir ./
#+header: :db exa.db
#+begin_src sqlite :results silent :eval never
sqlite> create table "foo" (id integer);
sqlite> drop TABLE foo;
sqlite> create table table (id integer);
Error: near "table": syntax error
sqlite> create table "TABLE" (id integer);
sqlite> drop table Table;
Error: near "Table": syntax error
sqlite> drop table "Table";
sqlite> .tables
#+end_src

*** Inserimento dati

    Per "popolare" una tabella, ossia per inserire dati, ossia per
    aggiungere righe, si usa il comando =insert into= che richiede il
    nome della tabella, la lista delle colonne in cui si vogliono
    inserire (tra parentesi separati da virgole) seguita dai dati (una
    lista di valori tra parentesi per ciascuna riga).

    *Nota:* la lista dei nomi delle colonne è *opzionale* nel qual caso si
    devono specificare dei valori per *tutte* le colonne (una
    scocciatura) e *esattamente nell'ordine* in cui sono state definite
    (ordine che di solito non si conosce!). Quindi in pratica: *non è
    opzionale*!

    *Nota:* in SQL il *delimitatore* per le stringhe è l'*apice singolo* e
    non le *virgolette* (o apice doppio).  Le virgolette servono per
    *quotare* i nomi degli identificatori quando si ci vuole complicare
    la vita!  Il fatto che quasi tutti i database (incluso SQLite) "si
    bevano" anche le virgolette non è un buon motivo per derogare (e
    il fatto di aver programmato in =C= per una vita nemmeno!).

#+header: :dir ./
#+header: :db exa.db
#+begin_src sqlite :results silent
insert into Person     -- nome della tabella
(name, code, age)           -- nomi delle colonne
values
('Linus', '123-L', 51),    -- valori, nelleo stesso ordine
('Richard', '444-R', 67),  -- in cui sono state specificate
('Bob', '666-B', 63);      -- le colonne!
#+end_src

*** Estrazione dei dati

    Con la =insert= abbiamo *scritto* dei nel database, adesso vediamo
    come, usando l'istruzione =select=, si possono *leggere*.

    *Nota*: come sinonimo di "leggere" si usa spesso il termine
    "estrarre" che però può generare confusione perché da l'idea che i
    dati vengono "tolti" dal database, cosa che non avviene.

    Per vedere il contenuto di una tabella si usa spesso questa
    espressione, che in pratica chiede di vedere il contenuto di tutte
    le colonne (l'asterisco) e di tutte le righe (perché questo è il
    comportamento normale in assenza di *filtri*).

#+name: select-asterisk
#+header: :dir ./
#+header: :db exa.db
#+begin_src sqlite :results output :exports both
select * from Person;
#+end_src

    E questo è un tipico risultato (il separatore di colonne dipende da
    molti fattori, ma la virgola è abbastanza normale).
#+RESULTS: select-asterisk
: 1,Linus,123-L,51
: 2,Richard,444-R,67
: 3,Bob,666-B,63

    In realtà, la "select con asterisco" è da evitare per vari motivi,
    primo tra tutti il fatto che si può sapere in anticipo quante
    saranno le colonne e quali "nomi" avranno.  Ricordarsi che le
    tabelle di una tabella possono cambiare nel tempo!  È quindi molto
    più corretto esplicitare sempre la lista delle colonne.

    *Nota*: per i "nomi" che seguono la /keyword/ =select= si usa spesso il
    termine di "colonna", ma il termine corretto è *descrittore di
    colonna*, per motivi che saranno chiari più avanti.
#+name: select-with-names
#+header: :dir ./
#+header: :db exa.db
#+begin_src sqlite :results output :exports both
select code, name from Person;
#+end_src

#+RESULTS: select-with-names
: 123-L,Linus
: 444-R,Richard
: 666-B,Bob

*** Funzionalità "non SQL" di SQLite

    La =select= appena vista è corretta, ma c'è un "piccolo problema":
    l'output non include i nomi (intestazioni) delle colonne.  È
    giusto così, perché non fanno parte del contenuto della tabella,
    sono dei *metadati*, ma ciò non toglie che sarebbe utile poterli
    includere nel risultato, almeno quando lo si vuol "visualizzare".

    Per fare questo si possono usare dei *comandi* che non fanno parte
    del linguaggio, ma che sono specifici dell'*interprete* SQLite.
#+name: select-fancy
#+header: :dir ./
#+header: :db exa.db
#+begin_src sqlite :results output :exports both
.header on
.separator |
.mode column
.width 3 5 8
select id, code, name from Person;
#+end_src

    E il risultato, molto più "bellino" del precedente, è:
#+RESULTS: select-fancy
: id   code   name
: ---  -----  --------
: 1    123-L  Linus
: 2    444-R  Richard
: 3    666-B  Bob

    I significato dei quattro comandi è il seguente:

    - header :: indica se mostrare (on) o no (off) le intestazioni,
    - separator ::  mi pare chiaro!
    - mode ::  indica il tipo di "formattazione" (html, csv, etc.)
    - width ::  la larghezza delle varie colonne.

* Local Variables                                                  :noexport:

# Local Variables:
# indent-tabs-mode: nil
# ispell-local-dictionary: "italian"
# flyspell-mode: t
# org-src-preserve-indentation: t
# org-confirm-babel-evaluate: nil
# org-src-fontify-natively: t
# tab-always-indent: nil
# End:


# lucama
# repl.luke.123
