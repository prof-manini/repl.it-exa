* headers                                                          :noexport:

#+INCLUDE: ~/standard-org-latex-export-headers.org
#+TITLE: Appunti sul "servizio" repl.it
#+AUTHOR: Luca Manini\footnote{\textcopyright\ 2020 Luca Manini}
#+DATE: Ottobre 2020
#+OPTIONS: toc:nil        no default TOC at all

* setup                                                            :noexport:

#+BEGIN_SRC elisp :results output
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)
(setq org-babel-load-languages
        '((emacs-lisp . t)
          (python . t)
          (sh . t)))
(setq python-shell-interpreter "python3")
#+END_SRC

#+RESULTS:

* Introduzione

  Alcuni appunti su "servizio" =repl.it= che utilizzeremo per fare
  esercizio di programmazione, sia in Python che in SQL (database).

* repl.it

  [[https://repl.it/][repl.it]] è uno strumento on-line via browser (Firefox e parenti) che
  permette di fare delle sessioni di programmazione in tantissimi
  linguaggi diversi, tra cui Python.

** Una nota sul nome del servizio.

   *repl* è un acronimo molto usato in informatica e sta per *read eval
   print loop*. Come spesso capita con gli acronimi in Inglese, anche
   questo si legge da destra a sinistra quindi si tratta di un
   programma che lavora in un *ciclo* (/loop/) in cui *stampa* (/ptiny/) ciò
   che ottiene *valutando* (/evaluate/) l'espressione che ha *letto* (/read/).

   Un repl è quindi, in generale, un'interfaccia utente (/user
   interface/) *testuale*, spesso chiamata anche *a linea di comando*
   (/command line/) verso un programma.  In questo caso il programma è
   un *interprete Python*, ossia un programma che è in grado di leggere,
   comprendere ed eseguire codice Python.

** Partenza

   Io non ho mai usato questo strumento prima d'ora e quindi:

   1. siamo tutti sulla stessa barca e sarà importante aiutarci a
      vicenda,
   2. secondo in questi appunti non do niente per scontato, anche se
      forse voi avete già fatto pratica e forse ne sapete più di me!

   Le prime funzionalità che mi pare utilizzeremo sono:

   1. la possibilità di creare e salvare più file sorgente (ossia file
      che contengono codice Python) che compariranno poi sulla colonna
      di sinistra,

   2. la possibilità di eseguire il codice presente in questi file,
      utilizzando il mega pulsante verde con la scritta RUN.
      *Attenzione*: repl esegue sempre e solo (direi) il file =main.py=,
      quindi almeno all'inizio useremo solo quello!

   3. la possibilità utilizzare Python in modalità "interattiva"
      scrivendo direttamente il codice nella finestra di destra (la
      stessa dove viene scritto ciò che stampa (/print/) il codice
      eseguito da file,

   4. la possibilità di usare, in futuro dopo che vi avrò spiegato
      cos'è a cosa serve e come si usa, un sistema di controllo di
      revisione,

** Iscrizione (account)

   Fortunatamente (ormai è purtroppo abbastanza raro), repl.it si può
   usare direttamente senza bisogno di registrarsi (/to sign up/) ma
   la registrazione è necessaria sia per poter "salvare" i sorgenti
   sia per poter utilizzare il sistema di controllo di revisione (vedi
   oltre).

* L'interprete interattivo

  Python è un linguaggio *interpretato*, il che vuol dire che il codice
  sorgente viene eseguito "così com'è" direttamente da un programma
  chiamato *interprete* invece di essere tradotto, da un programma
  chiamato di solito *compilatore* in un altro linguaggio comprensibile
  (ed eseguibile) da "un altro esecutore" (ad esempio "la CPU").

  Python, come succede spesso ma non sempre con i linguaggi
  interpretati, è anche un linguaggio *interattivo,* il che significa
  che è possibile "direttamente" scrivendo singole linee di codice che
  vengono eseguite "subito" e il cui risultato (se c'è) viene anche
  visualizzato (stampato) subito, *senza bisogno di usare la funzione
  print*!

  Questa modalità non è comoda per scrivere programmi di una certa
  lunghezza, ma è comodissima, tra le altre cose, per fare un po' di
  pratica con i concetti, i tipi di dato e le funzionalità di base del
  linguaggio.

** Pratica

   Vediamo quindi di fare un po' di pratica.

*** Espressioni semplici

    1. se scrivo 123 (e poi invio) l'interprete stampa 123, la ragione
       è che 123 è una *espressione* (anche se banale visto che è un
       literal), l'interprete la *valuta*, ottiene un *valore* a cui
       probabilmente siamo interessati e quindi lo stampa (senza dover
       usare print).

    2. se scrivo =a = 123=, l'interprete non stampa nulla, perché in
       Python le assegnazioni non sono espressioni, non hanno un
       valore e quini c'è poco da stampare!

    3. se però adesso scrivo =a=, l'interprete stampa 123, perché =a=
       (così da solo) è una espressione (un po' meno banale di un
       /literal/), quindi viene valutata, si ottiene un valore che viene
       stampato.

*** Tipi di dato

    Abbiamo già parlato di tipi di dato (/data types/) in generale e del
    fatto che anche in Python un dato è sempre di un certo tipo, che
    posso ottenere con la "funzione" =type=. Vediamo cosa ottengo se uso
    =type= passando un /literal/, un nome o una espressione.
#+BEGIN_SRC python :eval never
>>> type(123)
<class 'int'>
>>> a = 123
>>> type(a)
<class 'int'>
>>> type(100 + 23)
<class 'int'>
#+END_SRC

   Ottengo sempre lo stesso risultato, che indica che il tipo è =int=.
   Fate però attenzione: ciò non significa che il nome =a= è di tipo =int=
   o che l'espressione =123 + 543= è di tipo =int=; in tutti e tre i casi,
   come sempre, il *parametro attuale* che io passo ad una funzione
   viene prima di tutto valutato e poi *passato* alla funzione.  Ciò
   implica che in tutti e tre i casi, alla funzione =type= attiva un
   =123=, che è di tipo =int=!

   *Esercizio*: provate ad usare =type= con altri tipi di dato che
   conoscete.

*** Help

    Un'altra funzionalità da sfruttare nella modalità interattiva è la
    funzione =help=, che dà accesso alla documentazione /on-line/. Notare:
    l'informazione fornita da =help= è "interna" agli oggetti di cui
    chiedete la documentazione stessa ed è quindi sempre disponibile
    (non viene cercata su un qualche file esterno o in rete!).

    Vediamo un esempio con =help(print)=:
#+BEGIN_SRC python :eval never
>>> help(print)
Help on built-in function print in module builtins:

print(...)
    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file:  a file-like object (stream); defaults to the current sys.stdout.
    sep:   string inserted between values, default a space.
    end:   string appended after the last value, default a newline.
    flush: whether to forcibly flush the stream.
#+END_SRC

    Breve spiegazione:

    1. la prima riga ci dice che =print= è una funzione (/function/), in
       particolare è una funzione /built-in/ (ossia "già presente"
       nell'interprete) e che è definita nel modulo =builtins= (vedremo
       poi cosa sono i moduli).

    2. la riga successiva mostra la /signature/ della funzione, in
       pratica (potete pensare che sia) ciò che c'è scritto dopo =def=
       nella definizione di una funzione qualsiasi.

    3. =value= indica è il dato che vogliamo stampare,

    4. i tre puntini indicano che è possibile passare altri argomenti
       oltre al primo,

    5. =sep=, =end=, =file= e =flush= rappresentano degli argomenti opzionali
       (che vedremo nelle prossime lezioni...), e il valore dopo il
       segno di uguale indica il valore per difetto (/default value/)
       ossia il valore usato se non ne forniamo uno esplicitamente,

    6. le righe successive danno informazioni di dettaglio sui vari
       argomenti.

    *Nota importante*: quando definiamo delle funzioni, possiamo
    fornire la documentazione in una /docstring/, ossia in una stringa
    posta subito dopo la riga =def=.  Un esempio vale mille parole:

#+BEGIN_SRC python :eval never
>>> def hello(who):
...     "Say hello to WHO"
...     print("Hello " + who)
...
>>> hello("World")
Hello World
>>> help(hello)
Help on function hello in module __main__:

hello(who)
    Say hello to WHO
#+END_SRC

*** Completion (completamento?)

    Un'altra funzionalità molto utile è il completamento automatico.
    Molti "strumenti di sviluppo" forniscono un qualche meccanismo che
    "scrive per voi" o che almeno suggerisce cosa potreste scrivere.
    Uno molto utile è il completamento, in particolare il
    completamento delle "proprietà" (attributi, metodi etc.).

    Per esempio: se io ho una stringa e non sono bene "cosa posso
    farci", posso cercare tra i *metodi* (parenti delle funzioni)
    disponibili e per fare ciò mi basta scrivere un nome (purtroppo
    non funziona con i /literal/) e usare il tasto =TAB=.

    Esempio (in cui ho tolto alcune righe... e in cui nella seconda
    riga, dopo =name.= ho premuto il tasto =TAB=).
#+BEGIN_SRC python :eval never
>>> name = "Luca"
>>> name.
name.capitalize(    name.isalpha(       name.ljust(         name.split(
name.casefold(      name.isascii(       name.lower(         name.splitlines(
name.center(        name.isdecimal(     name.lstrip(        name.startswith(
............................................................................
name.index(         name.isupper(       name.rsplit(
name.isalnum(       name.join(          name.rstrip(
>>> help(name.lower)
Help on built-in function lower:

lower() method of builtins.str instance
    Return a copy of the string converted to lowercase.

>>> name.lower()
'luca'
#+END_SRC

* Codice "da file"

  Vediamo adesso anche un esempio in cui scriviamo del codice in un
  file e poi lo eseguiamo.

  1. usiamo il file =main.py= già creato da =repl=,

  2. inseriamo una funzione =sum_pos= che dato un "insieme di numeri"
     *calcola e restituisce* la somma dei soli positivi.
#+BEGIN_SRC python :session py :results silent
def sum_pos(ints):
    "The sum of the elements in INTS"
    t = 0              # creo un "accumulatore" nullo
    for i in ints:     # ciclo su tutti gli elementi di INTS
        if i > 0:      # e solamente se quello corrente è positivo
            t += i     # lo sommo all'accumulatore
    return t           # restituisco il risultato
#+END_SRC

  3. per fare un primo controllo proviamo ad usare la funzione in un
     paio di esempi,

#+NAME: sum-pos-test-0
#+BEGIN_SRC python :session py :results output :exports both
ii = (2,3,4,0-12)
t = sum_pos(ii)
print(ii, "->", t)
#+END_SRC

#+RESULTS: sum-pos-test-0
: (2, 3, 4, -12) -> 9

** Qualche "trucco" comodo

   Adesso abbiamo fatto una prova per vedere se la funzione =sum_pos=
   funziona correttamente; ma ovviamente una singola prova è un po'
   poco e soprattutto il "controllo" dobbiamo farlo noi, controllando
   ciò che stampa il codice di esempio.

   Per rendere il tutto un po' più comodo possiamo usare qualche
   trucco (in realtà non ci sono trucchi, ci sono solo modi
   intelligenti di usare le funzionalità del linguaggio!).

*** Esecuzione di più esempi

    Prima di tutto vediamo come eseguire la funzione =sum_pos= più
    volte con dati diversi.  La funzione richiede come argomento una
    lista (o simile) di interi, e quindi per fare più "giri" ci serve
    una lista di liste.
#+NAME: sum-pos-multi-test-0
#+BEGIN_SRC python :session py :results output :exports both
data = (
    (1,2,3),
    (0, -5, 7),
    (3 -4, 0, 2),
    )
for ii in data:
    t = sum_pos(ii)
    print(ii, "->", t)
#+END_SRC

#+RESULTS: sum-pos-multi-test-0
: (1, 2, 3) -> 6
: (0, -5, 7) -> 7
: (-1, 0, 2) -> 2


* Local Variables                                                  :noexport:

# Local Variables:
# indent-tabs-mode: nil
# ispell-local-dictionary: "italian"
# flyspell-mode: t
# org-src-preserve-indentation: t
# org-confirm-babel-evaluate: nil
# org-src-fontify-natively: t
# tab-always-indent: nil
# End:


# lucama
# repl.luke.123
